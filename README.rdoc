= Wedge README

* +home+: http://github.com/proutils/wedge
* +code+: http://github.com/proutils/wedge
* +talk+: http://groups.google.com/group/rubyworks-mailinglist


== DESCRIPTION

The wedge gem provides an easy to use interface for adding custom
load managers to Ruby's standard load system (the #load and #require methods).


== SYNOPSIS

Wedge was written initially to provide the single capability of loading
Ruby standard libraries without potential interference from installed
gems. The code naturally evolved into something more generic, useful for
writing any kind of add-on load manager. The code for the Ruby wedge serves
as a good example of writing a wedge.

  require 'wedge/kernel'
  require 'rbconfig'

  Wedge.new :Ruby do

    # Notice that rubylibdir takes precedence.
    LOCATIONS = ::RbConfig::CONFIG.values_at(
      'rubylibdir', 'archdir', 'sitelibdir', 'sitearchdir'
    )

    #
    def call(fname, options={})
      return unless md = /^ruby[:\/]/.match(fname)

      file = md.post_match

      LOCATIONS.each do |loadpath|
        if path = find(loadpath, file, options)
          return super(path, options)
        end
      end

      raise LoadError, "no such file to load -- #{fname}"
    end

  end

Wedge.new is actually just a helper method. One could write a load wedge without
it as the interface is very simple. Any object the responds to #call taking
parameters of <code>(fname, options={})</code> can be used as a load wedge. 
Simply register it via:

  Wedge.register(mywedge)

Wedge.new makes it a bit easier by automatically creating an object extended by
the Wedge::Helper module, which provides a few methods that can be generally
useful to any load manager, and then registers the object as a load wedge
automatically. As the example above shows, it also allows one to name their
wedge, which can be useful for debugging load issues.

You might wonder how the single method, #call, handles both #load and #require
operations. The secret is in the +options+ hash. If <code>options[:load]</code>
resolves to true, then it is a +load+ operation, otherwise it is a +require+
operation.

As wedges are registered, they are added to a list in order of registration.
When #load or #require is called each wedge is tried in turn. The return value
of #call controls how this loop proceeds. If the return value is +true+ then the
load was successful, and the loop can break. If it is +false+ it means the
loading has already been handled and the loop can also break. But if the
return value is +nil+, it means the wedge does not apply and the loop should
continue. If all wedges have been tried and all have returned +nil+ then it
falls back to the original #load and #require calls.

Wedge provides two wedges out-of-the-box, the Ruby wedge and the Gem wedge.

=== Ruby Wedge

The Ruby wedge is considered standard fare. When you require 'wedge' it will
load the wedge kernel and also the Ruby wedge.

The Ruby wedge makes it possible to load a Ruby standard library without
interference from installed gems or other package systems.

  require 'wedge'

  require 'ruby:ostruct'

This will load the ostruct.rb script from the Ruby standard library regardless
of whether some newbie dropped an ostruct.rb file in their projects lib/ 
directory without understand the consequences.


=== Gem Wedge

The Gem wedge is similar to the Ruby wedge, in that it isolates the loading
of a gem's files from other gems.

  require 'wedge/gem'

  gem 'facets', '~>2.8'

  require 'facets:string/margin'

With this we can be sure that 'facets/string/margin' was loaded from the facets
library regardless of whether some other gem put a 'facets/string/margin' file
in their lib/ directory.

To use the Gem wedge, add it to your RUBYOPT environment variable, e.g.

  RUBYOPT="-rwedge/gem"

The Gem wedge will load `rubygems.rb` automatically so you don't need to
have both `-rubygems` and `-rwedge/gem` in the same RUBYOPT.

==== Why

One of the rarely mention edge cases with the way in which RubyGems loads
library files, and in fact the way Ruby's load system works in general, is
that the "lib space" is a free for all. Any library can drop any file into
their package's lib/ directory and potentially clobber a file of the same name
in some one else's library. Now, a good <i>gem citizen</i> knows to put their 
scripts in a directory with the same name as their gem package, nonetheless you
might be surprised to see how often this simple but important practice is
violated.[1] Consequently the order in which such gems are searched becomes of
paramount importance --something that worked just fine on one machine can
suddenly stop working on another for no obvious reason.

It is also worth noting that the recent crop of gem isolation systems, such as
Bundler and Isolate, while serving to reduce the likelihood of possible name
clashes still do not fully remedy the issue. They merely reduce the number to
gems that could cause the problem for any given dependent application.

[1] See the INFRACTIONS.rdoc file for examples.

==== How

The Gem Wedge solves the issue entirely by allowing you to load files directly
for a single gem and only that gem. It does so by adding a new valid syntax
to Ruby's #load and #require methods. As an example, let's say we wanted to
load the troff.rb script from the unroller library.

  require 'unroller:troff'

The colon is used to separate the gem name from the rest of the pathname.
With this we can be 100% certain that the troff.rb file was required
from the unroller gem and not a 'troff.rb' file from any other
gem that might have created a script by the same name.


== INSTALL

  $ gem install wedge


== LEGAL

Wedge, Copyright (c) 2010 Thomas Sawyer

Wedge is distributed under the terms of the Apache 2.0 License.

See LICENSE file for more details.

